package v1alpha1

import (
	"fmt"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/yaml"
)

const (
	// HighAvailabilityFailureToleranceNode specifies that the control plane is tolerant to node failures within a single zone.
	HighAvailabilityFailureToleranceNode = "node"
	// HighAvailabilityFailureToleranceZone specifies that the control plane is tolerant to zone failures.
	HighAvailabilityFailureToleranceZone = "zone"
)

// GardenerConfiguration contains the configuration that is required for setting up a Gardener-based APIServer.
// +kubebuilder:validation:XValidation:rule="has(self.highAvailability) == has(oldSelf.highAvailability) || has(self.highAvailability)",message="highAvailability is required once set"
type GardenerConfiguration struct {
	// Region is the region to be used for the Shoot cluster.
	// This is usually derived from the ManagedControlPlane's common configuration, but can be overwritten here.
	// +kubebuilder:validation:XValidation:message="region is immutable",rule="self == oldSelf"
	// +kubebuilder:validation:Optional
	Region string `json:"region,omitempty"`

	// HighAvailabilityConfig specifies the HA configuration for the API server.
	// +kubebuilder:validation:XValidation:message="highAvailability is immutable",rule="self == oldSelf"
	// +kubebuilder:validation:Optional
	HighAvailabilityConfig *HighAvailabilityConfig `json:"highAvailability,omitempty"`

	// AuditLogConfig defines the AuditLog configuration for the ManagedControlPlane cluster.
	// +kubebuilder:validation:Optional
	AuditLog *AuditLogConfig `json:"auditLog,omitempty"`

	// EncryptionConfig contains customizable encryption configuration of the API server.
	// +optional
	EncryptionConfig *EncryptionConfig `json:"encryptionConfig,omitempty"`
}

type GardenerInternalConfiguration struct {
	// ShootOverwrite allows to overwrite the shoot to be used. This could be useful for migration tasks.
	// +kubebuilder:validation:Optional
	ShootOverwrite *NamespacedObjectReference `json:"shootOverwrite,omitempty"`

	// K8SVersionOverwrite is the k8s version for the Shoot cluster.
	// Will be defaulted if not specified.
	// +kubebuilder:validation:Optional
	K8SVersionOverwrite string `json:"k8sVersionOverwrite,omitempty"`

	// LandscapeConfiguration is the name of the landscape and the name of the configuration to use.
	// The expected format is "<landscape-name>/<config-name>".
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:Pattern="^[a-z0-9-]+/[a-z0-9-]+$"
	// +kubebuilder:validation:XValidation:rule="self == oldSelf",message="Value is immutable"
	LandscapeConfiguration string `json:"landscapeConfiguration,omitempty"`
}

// HighAvailabilityConfig specifies the High Availability configuration for the API server.
type HighAvailabilityConfig struct {
	// FailureToleranceType specifies failure tolerance mode for the API server.
	// Allowed values are: node, zone
	// node: The API server is tolerant to node failures within a single zone.
	// zone: The API server is tolerant to zone failures.
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:XValidation:rule="self == oldSelf",message="failureToleranceType is immutable"
	// +kubebuilder:validation:Enum=node;zone
	FailureToleranceType string `json:"failureToleranceType"`
}

// AuditLogConfig defines the AuditLog configuration for the resource cluster (shoot cluster).
type AuditLogConfig struct {
	// Type is the type of the audit log.
	// +kubebuilder:validation:Enum=standard
	Type string `json:"type"`

	// TenantID is the tenant ID of the BTP Subaccount. Can be seen in the BTP Cockpit dashboard.
	TenantID string `json:"tenantID"`

	// ServiceURL is the URL from the Service Keys.
	ServiceURL string `json:"serviceURL"`

	// SecretRef is the reference to the secret containing the credentials for the audit log service.
	SecretRef corev1.LocalObjectReference `json:"secretRef"`

	// PolicyRef is the reference to the policy containing the configuration for the audit log service.
	PolicyRef corev1.LocalObjectReference `json:"policyRef"`
}

// EncryptionConfig contains customizable encryption configuration of the API server.
type EncryptionConfig struct {
	// Resources contains the list of resources that shall be encrypted in addition to secrets.
	// Each item is a Kubernetes resource name in plural (resource or resource.group) that should be encrypted.
	// Example: ["configmaps", "statefulsets.apps", "flunders.emxample.com"]
	Resources []string `json:"resources,omitempty"`
}

// GardenerStatus contains internal status for 'Gardener' type APIServer.
type GardenerStatus struct {
	// Shoot contains the shoot manifest generated by the controller.
	// +kubebuilder:pruning:PreserveUnknownFields
	// +optional
	Shoot *runtime.RawExtension `json:"shoot,omitempty"`
}

func (gc *GardenerConfiguration) Default() {

}

func (gc *GardenerConfiguration) Validate(fldPath *field.Path) field.ErrorList {
	if gc == nil {
		return nil
	}
	allErrs := field.ErrorList{}

	// TODO validate OIDC config?

	return allErrs
}

// GetShoot returns the shoot in the GardenerStatus as unstructured object.
// Returns nil if no shoot is contained in the GardenerStatus.
func (gs *GardenerStatus) GetShoot() (*unstructured.Unstructured, error) {
	if gs == nil || gs.Shoot == nil {
		return nil, nil
	}
	if gs.Shoot.Object != nil {
		// this is mostly relevant for tests
		uShoot, ok := gs.Shoot.Object.(*unstructured.Unstructured)
		if ok {
			return uShoot, nil
		}
	}
	if gs.Shoot.Raw != nil {
		uShoot := &unstructured.Unstructured{}
		if err := yaml.Unmarshal(gs.Shoot.Raw, uShoot); err != nil {
			return nil, fmt.Errorf("failed to unmarshal shoot: %w", err)
		}
		return uShoot, nil
	}
	return nil, nil
}
